# leads/services/linkedin_api.py
import requests
import json
import logging
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)


class LinkedInAPIService:
    """
    Service to interact with LinkedIn API at linkedin.programando.io
    
    IMPORTANT NOTES BASED ON REAL API DATA:
    - API accepts ONLY ONE filter at a time (position, level, or company_industry)
    - Multiple filters cause 500 errors
    - Location/region filters don't work on API side
    - All other filters must be applied client-side
    
    API Data Structure:
    {
        "location": "United States",           // Country name
        "region": "Northern America",          // Geographical region
        "position": "Director",                // Job title
        "level": "Director",                   // Seniority level
        "company_name": "Top 000",            
        "company_industry": "Construction",
        "company_headcount": "1-10 employees",
        "skills": "...",
        "headline": "...",
        ...
    }
    
    Includes automatic fallback to mock data when API is unavailable.
    """
    
    def __init__(self):
        """Initialize the LinkedIn API service"""
        self.api_url = "https://linkedin.programando.io/fetch_lead2"
        self.session = requests.Session()
    
    def fetch_leads(self, filters: Dict) -> Dict:
        """
        Fetch leads from LinkedIn API with automatic fallback.
        
        Args:
            filters: Dictionary containing search filters
        
        Returns:
            Dictionary with 'success', 'results', 'total', 'error', and 'is_mock' keys
        """
        try:
            body = self._build_request_body(filters)
            
            headers = {
                "Content-Type": "application/json",
                "User-Agent": "PostmanRuntime/7.49.1"
            }
            
            logger.info(f"Attempting API call: {self.api_url}")
            logger.info(f"Request body: {json.dumps(body, indent=2)}")
            
            response = requests.get(
                self.api_url,
                data=json.dumps(body),
                headers=headers,
                timeout=10  # Short timeout - if API is down, fail fast
            )
            
            logger.info(f"API response status: {response.status_code}")
            
            # If error 500 or any error, use mock immediately
            if response.status_code != 200:
                logger.error(f"API error {response.status_code} - switching to mock data")
                return self._get_mock_data(filters)
            
            data = response.json()
            results = data.get('results', [])
            
            # Apply local filters since API doesn't support multiple filters
            if filters:
                results = self.filter_leads_locally(results, filters)
            
            logger.info(f"Successfully fetched {len(results)} leads from real API")
            
            return {
                'success': True,
                'results': results,
                'total': len(results),
                'error': None,
                'is_mock': False
            }
            
        except requests.exceptions.Timeout:
            logger.warning("API timeout - switching to mock data")
            return self._get_mock_data(filters)
            
        except requests.exceptions.RequestException as e:
            logger.warning(f"API connection error: {e} - switching to mock data")
            return self._get_mock_data(filters)
            
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON from API - switching to mock data")
            return self._get_mock_data(filters)
            
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)} - switching to mock data")
            return self._get_mock_data(filters)
    
    def _get_mock_data(self, filters: Dict) -> Dict:
        """Fetch mock data when API is unavailable"""
        try:
            from .mock_linkedin_data import MockLinkedInData
            
            limit = filters.get('limit', 50)
            logger.info(f"Generating {limit} mock leads")
            
            mock_leads = MockLinkedInData.generate_leads(count=limit, filters=filters)
            
            return {
                'success': True,
                'results': mock_leads,
                'total': len(mock_leads),
                'error': None,
                'is_mock': True
            }
        except Exception as e:
            logger.error(f"Error generating mock data: {e}")
            return {
                'success': False,
                'results': [],
                'total': 0,
                'error': f"Both API and mock data failed: {e}",
                'is_mock': False
            }
    
    def _build_request_body(self, filters: Dict) -> Dict:
        """
        Build request body from filters.
        
        CRITICAL: API ONLY accepts ONE filter at a time!
        Multiple filters cause 500 Internal Server Error.
        
        Priority order (based on testing):
        1. position (title) - works best
        2. level (seniority) - works well
        3. company_industry - works well
        
        All other filters (location, region, company, name, etc.) 
        will be applied client-side.
        """
        body = {}
        
        # Always include limit
        limit = filters.get('limit', 50)
        try:
            body['limit'] = min(int(limit), 1000)
        except (ValueError, TypeError):
            body['limit'] = 50
        
        # PRIORITY 1: Position/Title (best performance)
        if filters.get('title'):
            body['position'] = [filters['title']]
            logger.debug("Using API filter: position")
            return body
        
        # PRIORITY 2: Seniority Level
        if filters.get('seniority_level'):
            seniority_map = {
                'entry': 'Entry Level',
                'mid': 'Mid Level',
                'senior': 'Senior',
                'specialist': 'Specialist',
                'manager': 'Manager',
                'director': 'Director',
                'head': 'Head',
                'vp': 'VP',
                'c_level': 'C-Level',
                'owner': 'Owner',
                'partner': 'Partner',
                'intern': 'Intern',
            }
            mapped_level = seniority_map.get(
                filters['seniority_level'], 
                filters['seniority_level'].title()
            )
            body['level'] = [mapped_level]
            logger.debug(f"Using API filter: level = {mapped_level}")
            return body
        
        # PRIORITY 3: Industry
        if filters.get('industry'):
            body['company_industry'] = [filters['industry']]
            logger.debug("Using API filter: company_industry")
            return body
        
        # DO NOT send location, region, company, or name to API
        # They either don't work or cause timeouts/errors
        # They will be filtered client-side
        
        logger.debug("No API filters applied - all filtering will be client-side")
        return body
    
    def parse_lead_data(self, raw_lead: Dict) -> Dict:
        """
        Parse raw lead data from API into our Lead model format.
        
        Maps API fields to our database fields:
        - name + surname -> first_name, last_name, full_name
        - linkedin -> linkedin_url
        - position -> current_title
        - company_name -> current_company
        - location -> location (this is the country in API)
        - region -> country (geographical region)
        - company_industry -> industry
        - company_headcount -> company_size
        - level -> level and seniority_level
        """
        try:
            first_name = raw_lead.get('name', '')
            last_name = raw_lead.get('surname', '')
            full_name = f"{first_name} {last_name}".strip()
            
            # Normalize LinkedIn URL
            linkedin_url = raw_lead.get('linkedin', '')
            if linkedin_url and not linkedin_url.startswith('http'):
                linkedin_url = f'https://{linkedin_url}'
            
            # Map seniority level
            level = raw_lead.get('level', '')
            seniority = self._map_seniority(level)
            
            parsed = {
                'external_id': str(raw_lead.get('id', '')),
                'first_name': first_name,
                'last_name': last_name,
                'full_name': full_name,
                'email': raw_lead.get('email', ''),
                'phone': raw_lead.get('phone', ''),
                'linkedin_url': linkedin_url,
                'photo_url': None,
                
                # Professional info
                'current_title': raw_lead.get('position', ''),
                'current_company': raw_lead.get('company_name', ''),
                'company_linkedin_url': raw_lead.get('company_linkedin', ''),
                'headline': raw_lead.get('headline', ''),
                'level': raw_lead.get('level', ''),
                'department': raw_lead.get('department', ''),
                
                # Location mapping based on REAL API structure:
                # API "location" = actual country (e.g., "United States")
                # API "region" = geographical region (e.g., "Northern America")
                'location': raw_lead.get('location', ''),      # Country name
                'country': raw_lead.get('region', ''),         # Geographical region
                'region': raw_lead.get('region', ''),          # Keep consistency
                
                # Company info
                'industry': raw_lead.get('company_industry', ''),
                'company_size': raw_lead.get('company_headcount', ''),
                'company_domain': raw_lead.get('company_domain', ''),
                'company_location': raw_lead.get('company_location', ''),
                'company_founded': str(raw_lead.get('company_founded', '')),
                'company_revenue': raw_lead.get('company_revenue', ''),
                'company_subindustry': raw_lead.get('company_subindustry', ''),
                
                # Additional
                'seniority_level': seniority,
                'skills': raw_lead.get('skills', ''),
                'bio': raw_lead.get('headline', ''),
            }
            
            return parsed
            
        except Exception as e:
            logger.error(f"Error parsing lead data: {str(e)}", exc_info=True)
            raise
    
    def _map_seniority(self, api_level: str) -> str:
        """
        Map API seniority level string to our database choices.
        
        Based on real API data, possible values include:
        - Specialist, Entry Level, Mid Level, Senior
        - Manager, Director, Head, VP
        - C-Level, Owner, Founder, Partner
        - Intern
        """
        if not api_level:
            return ''
        
        level_lower = api_level.lower().strip()
        
        mapping = {
            # Entry levels
            'entry': 'entry',
            'entry level': 'entry',
            'junior': 'entry',
            'intern': 'intern',
            
            # Mid levels
            'mid': 'mid',
            'mid level': 'mid',
            'intermediate': 'mid',
            
            # Senior levels
            'senior': 'senior',
            'sr': 'senior',
            'senior level': 'senior',
            
            # Specialist
            'specialist': 'specialist',
            
            # Management
            'manager': 'manager',
            'mgr': 'manager',
            'head': 'head',
            
            # Directors
            'director': 'director',
            'dir': 'director',
            
            # VP
            'vp': 'vp',
            'vice president': 'vp',
            
            # C-Level
            'c-level': 'c_level',
            'c level': 'c_level',
            'executive': 'c_level',
            'ceo': 'c_level',
            'cto': 'c_level',
            'cfo': 'c_level',
            'coo': 'c_level',
            'cmo': 'c_level',
            
            # Owners
            'owner': 'owner',
            'founder': 'owner',
            
            # Partners
            'partner': 'partner',
        }
        
        return mapping.get(level_lower, '')
    
    def filter_leads_locally(self, leads: List[Dict], filters: Dict) -> List[Dict]:
        """
        Apply client-side filters to leads.
        
        This is necessary because the API doesn't support multiple filters
        or certain filters like location, region, company name, etc.
        
        Filters applied:
        - name: searches in first name + last name
        - company: searches in company_name
        - location: searches in location field (country name in API)
        - region: searches in region field (geographical region in API)
        - seniority_level: exact match on mapped seniority
        - company_size: exact match on company_headcount
        - industry: substring search in company_industry
        - keywords: searches in skills, headline, and position
        """
        if not filters:
            return leads
        
        filtered = leads
        original_count = len(leads)
        
        # Filter by name (first name + last name)
        name = filters.get('name', '').lower()
        if name:
            filtered = [
                lead for lead in filtered 
                if name in f"{lead.get('name', '')} {lead.get('surname', '')}".lower()
            ]
            logger.debug(f"Name filter '{name}': {original_count} -> {len(filtered)} leads")
        
        # Filter by company
        company = filters.get('company', '').lower()
        if company:
            filtered = [
                lead for lead in filtered 
                if company in lead.get('company_name', '').lower()
            ]
            logger.debug(f"Company filter '{company}': {len(leads)} -> {len(filtered)} leads")
        
        # Filter by location (API "location" field contains country names)
        location = filters.get('location', '').lower()
        if location:
            filtered = [
                lead for lead in filtered 
                if location in lead.get('location', '').lower()
            ]
            logger.debug(f"Location filter '{location}': {len(leads)} -> {len(filtered)} leads")
        
        # Filter by region (API "region" field contains geographical regions)
        region = filters.get('region', '').lower()
        if region:
            filtered = [
                lead for lead in filtered 
                if region in lead.get('region', '').lower()
            ]
            logger.debug(f"Region filter '{region}': {len(leads)} -> {len(filtered)} leads")
        
        # Filter by seniority level (only if not already filtered by API)
        if not filters.get('seniority_level'):
            seniority = filters.get('seniority_level')
            if seniority:
                filtered = [
                    lead for lead in filtered 
                    if self._map_seniority(lead.get('level', '')) == seniority
                ]
                logger.debug(f"Seniority filter '{seniority}': {len(leads)} -> {len(filtered)} leads")
        
        # Filter by company size
        company_size = filters.get('company_size')
        if company_size:
            filtered = [
                lead for lead in filtered 
                if lead.get('company_headcount', '') == company_size
            ]
            logger.debug(f"Company size filter '{company_size}': {len(leads)} -> {len(filtered)} leads")
        
        # Filter by industry (only if not already filtered by API)
        if not filters.get('industry'):
            industry_filter = filters.get('industry', '').lower()
            if industry_filter:
                filtered = [
                    lead for lead in filtered 
                    if industry_filter in lead.get('company_industry', '').lower()
                ]
                logger.debug(f"Industry filter '{industry_filter}': {len(leads)} -> {len(filtered)} leads")
        
        # Filter by keywords (searches in skills, headline, position)
        keywords = filters.get('keywords', '').lower()
        if keywords:
            filtered = [
                lead for lead in filtered 
                if (keywords in lead.get('skills', '').lower() or
                    keywords in lead.get('headline', '').lower() or
                    keywords in lead.get('position', '').lower())
            ]
            logger.debug(f"Keywords filter '{keywords}': {len(leads)} -> {len(filtered)} leads")
        
        logger.info(f"Local filtering complete: {original_count} -> {len(filtered)} leads")
        
        return filtered