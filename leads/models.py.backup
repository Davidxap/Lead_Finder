# leads/models.py
from django.db import models
from django.core.validators import URLValidator
from django.utils.text import slugify
from typing import List, TYPE_CHECKING, Dict, Any

if TYPE_CHECKING:
    from django.db.models.manager import RelatedManager


class Lead(models.Model):
    """
    Model to store lead information from LinkedIn API.
    Each lead represents a person with professional information.
    
    Field mapping from API:
    - API "location" -> DB "location" (country name like "United States")
    - API "region" -> DB "country" (geographical region like "Northern America")
    - API "position" -> DB "current_title"
    - API "level" -> DB "level" and "seniority_level"
    - API "company_name" -> DB "current_company"
    - API "company_industry" -> DB "industry"
    - API "company_headcount" -> DB "company_size"
    """
    
    # Explicit ID for type checkers
    id = models.AutoField(primary_key=True)
    
    # Basic Information (mapped from API: name, surname)
    first_name = models.CharField(max_length=100, db_index=True, blank=True)
    last_name = models.CharField(max_length=100, db_index=True, blank=True)
    full_name = models.CharField(max_length=200, blank=True)
    
    # Contact Information
    email = models.EmailField(max_length=255, blank=True, null=True)
    phone = models.CharField(max_length=50, blank=True, null=True)
    
    # LinkedIn Information (mapped from API: linkedin)
    linkedin_url = models.URLField(max_length=500, blank=True, validators=[URLValidator()])
    photo_url = models.URLField(max_length=500, blank=True, null=True)
    
    # Professional Information (mapped from API: position, headline, level, department)
    current_title = models.CharField(max_length=255, db_index=True, blank=True)
    current_company = models.CharField(max_length=255, db_index=True, blank=True)
    company_linkedin_url = models.URLField(max_length=500, blank=True)
    headline = models.TextField(blank=True)
    level = models.CharField(max_length=100, blank=True)  # API: level
    department = models.CharField(max_length=100, blank=True)  # API: department
    
    # Location (mapped from API structure)
    # API "location" contains country names like "United States"
    # API "region" contains geographical regions like "Northern America"
    location = models.CharField(max_length=255, db_index=True, blank=True)
    country = models.CharField(max_length=100, db_index=True, blank=True)
    region = models.CharField(max_length=100, blank=True)  # API: region
    
    # Company Information (mapped from API: company_*)
    industry = models.CharField(max_length=255, db_index=True, blank=True)  # API: company_industry
    company_size = models.CharField(max_length=100, blank=True)  # API: company_headcount
    company_domain = models.CharField(max_length=255, blank=True)  # API: company_domain
    company_location = models.CharField(max_length=255, blank=True)  # API: company_location
    company_founded = models.CharField(max_length=50, blank=True)  # API: company_founded
    company_revenue = models.CharField(max_length=100, blank=True)  # API: company_revenue
    company_subindustry = models.TextField(blank=True)  # API: company_subindustry
    
    # Seniority (updated to match real API data)
    SENIORITY_CHOICES = [
        ('entry', 'Entry Level'),
        ('mid', 'Mid Level'),
        ('senior', 'Senior'),
        ('specialist', 'Specialist'),  # Found in API data
        ('manager', 'Manager'),
        ('director', 'Director'),
        ('head', 'Head'),  # Found in API data
        ('vp', 'VP'),
        ('c_level', 'C-Level'),
        ('owner', 'Owner'),
        ('partner', 'Partner'),
        ('intern', 'Intern'),  # Found in API data
    ]
    seniority_level = models.CharField(
        max_length=20, 
        choices=SENIORITY_CHOICES, 
        blank=True,
        db_index=True
    )
    
    # Additional Information (mapped from API: skills)
    skills = models.TextField(blank=True, help_text="Comma-separated skills")
    bio = models.TextField(blank=True)
    
    # External Reference (mapped from API: id)
    external_id = models.CharField(
        max_length=255, 
        unique=True, 
        db_index=True,
        help_text="Unique identifier from LinkedIn API",
        null=True  # Allow null for leads created manually
    )
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    if TYPE_CHECKING:
        list_items: 'RelatedManager[LeadListItem]'
    
    class Meta:
        db_table = 'leads'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['first_name', 'last_name']),
            models.Index(fields=['current_company']),
            models.Index(fields=['country', 'location']),
            models.Index(fields=['industry']),
            models.Index(fields=['seniority_level']),
            models.Index(fields=['external_id']),
        ]
        verbose_name = 'Lead'
        verbose_name_plural = 'Leads'
    
    def __str__(self) -> str:
        return f"{self.get_full_name()} - {self.current_company}"
    
    def save(self, *args, **kwargs) -> None:
        """Override save to auto-populate full_name"""
        if not self.full_name:
            self.full_name = self.get_full_name()
        super().save(*args, **kwargs)
    
    def get_full_name(self) -> str:
        """Return full name of the lead"""
        return f"{self.first_name} {self.last_name}".strip()
    
    def get_skills_list(self) -> List[str]:
        """Return skills as a list"""
        if self.skills:
            return [skill.strip() for skill in self.skills.split(',')]
        return []
    
    def has_email(self) -> bool:
        """Check if lead has email"""
        return bool(self.email)
    
    def has_phone(self) -> bool:
        """Check if lead has phone"""
        return bool(self.phone)
    
    @classmethod
    def from_api_data(cls, data: Dict[str, Any]) -> 'Lead':
        """
        Create a Lead instance from API response data.
        
        API structure (based on real data):
        {
            "id": 2566,
            "name": "Fred",
            "surname": "Fred",
            "linkedin": "linkedin.com/in/fred-fred-ab886026",
            "location": "United States",              # Country name
            "region": "Northern America",             # Geographical region
            "position": "A Good One",
            "headline": "a good one at Topco",
            "level": "Specialist",
            "department": "",
            "skills": "",
            "company_name": "Top 000",
            "company_domain": "0.be",
            "company_linkedin": "https://www.linkedin.com/company/topco",
            "company_location": "Belgium",
            "company_industry": "Construction",
            "company_subindustry": "...",
            "company_headcount": "1-10 employees",
            "company_founded": "",
            "company_revenue": "Not Known"
        }
        """
        # Normalize LinkedIn URL
        linkedin_url = data.get('linkedin', '')
        if linkedin_url and not linkedin_url.startswith('http'):
            linkedin_url = f'https://{linkedin_url}'
        
        # Normalize company LinkedIn URL
        company_linkedin = data.get('company_linkedin', '')
        
        # Map seniority level
        level = data.get('level', '').lower()
        seniority_mapping = {
            'specialist': 'specialist',
            'entry': 'entry',
            'entry level': 'entry',
            'mid': 'mid',
            'mid level': 'mid',
            'senior': 'senior',
            'manager': 'manager',
            'director': 'director',
            'head': 'head',
            'vp': 'vp',
            'c-level': 'c_level',
            'owner': 'owner',
            'founder': 'owner',
            'partner': 'partner',
            'intern': 'intern',
        }
        seniority = seniority_mapping.get(level, '')
        
        return cls(
            # Basic info
            first_name=data.get('name', ''),
            last_name=data.get('surname', ''),
            
            # LinkedIn
            linkedin_url=linkedin_url,
            
            # Professional info
            current_title=data.get('position', ''),
            current_company=data.get('company_name', ''),
            headline=data.get('headline', ''),
            level=data.get('level', ''),
            department=data.get('department', ''),
            
            # Location mapping (corrected based on real API structure)
            location=data.get('location', ''),      # Country name from API
            country=data.get('region', ''),         # Geographical region from API
            region=data.get('region', ''),          # Keep consistency
            
            # Company info
            company_linkedin_url=company_linkedin,
            industry=data.get('company_industry', ''),
            company_size=data.get('company_headcount', ''),
            company_domain=data.get('company_domain', ''),
            company_location=data.get('company_location', ''),
            company_founded=data.get('company_founded', ''),
            company_revenue=data.get('company_revenue', ''),
            company_subindustry=data.get('company_subindustry', ''),
            
            # Additional
            seniority_level=seniority,
            skills=data.get('skills', ''),
            
            # External reference
            external_id=str(data.get('id', ''))
        )


class LeadList(models.Model):
    """
    Model to store custom lists created by users.
    Users can organize leads into different lists.
    """
    
    # Explicit ID for type checkers
    id = models.AutoField(primary_key=True)
    
    name = models.CharField(
        max_length=255, 
        unique=True, 
        db_index=True,
        help_text="Unique name for the list"
    )
    description = models.TextField(blank=True)
    slug = models.SlugField(max_length=255, unique=True, blank=True)
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    if TYPE_CHECKING:
        list_items: 'RelatedManager[LeadListItem]'
    
    class Meta:
        db_table = 'lead_lists'
        ordering = ['-created_at']
        verbose_name = 'Lead List'
        verbose_name_plural = 'Lead Lists'
    
    def __str__(self) -> str:
        return self.name
    
    def save(self, *args, **kwargs) -> None:
        """Override save to auto-generate slug"""
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)
    
    def get_lead_count(self) -> int:
        """Return number of leads in this list"""
        return self.list_items.count()
    
    def get_leads(self) -> models.QuerySet['Lead']:
        """Return all leads in this list"""
        return Lead.objects.filter(list_items__lead_list=self)


class LeadListItem(models.Model):
    """
    Model to store the many-to-many relationship between Leads and Lists.
    This allows tracking when a lead was added to a list.
    """
    
    # Explicit ID for type checkers
    id = models.AutoField(primary_key=True)
    
    lead = models.ForeignKey(
        Lead, 
        on_delete=models.CASCADE, 
        related_name='list_items'
    )
    lead_list = models.ForeignKey(
        LeadList, 
        on_delete=models.CASCADE, 
        related_name='list_items'
    )
    added_at = models.DateTimeField(auto_now_add=True)
    notes = models.TextField(blank=True, help_text="Optional notes about this lead in this list")
    
    class Meta:
        db_table = 'lead_list_items'
        unique_together = ('lead', 'lead_list')  # Prevent duplicates
        ordering = ['-added_at']
        verbose_name = 'Lead List Item'
        verbose_name_plural = 'Lead List Items'
    
    def __str__(self) -> str:
        return f"{self.lead.get_full_name()} in {self.lead_list.name}"